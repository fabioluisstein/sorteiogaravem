import React, { useRef, useState, useEffect } from "react";
import {
  apartamentoTemDireitoDupla,
  positionToSequentialNumber,
  getExclusiveApartmentType,
  validateConfigExclusivity,
  loadConfigFromFile,
  isVagaEstendida,
  apartmentoPodeVagaEstendida
} from "./config/sorteioConfig.js";/* ===== Aleatoriedade ===== */
function mulberry32(seed) {
  let t = seed >>> 0;
  return function () {
    t += 0x6d2b79f5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function seededShuffle(arr, rand) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ===== Converte ID da vaga para n√∫mero sequencial ===== */
function vagaIdToSequentialNumber(vagaId) {
  // vagaId formato: "G1-A1", "G1-A2", etc.
  const match = vagaId.match(/^(G\d+)-([A-F])(\d+)$/);
  if (!match) return vagaId; // fallback se n√£o conseguir converter

  const floor = match[1];
  const side = match[2];
  const position = Number.parseInt(match[3]);

  return positionToSequentialNumber(floor, side, position);
}

/* ===== Configura√ß√£o ===== */
/* Use canonical values from configuration (sorteio.properties). */
import { VAGAS_CONFIG } from "./config/sorteioConfig.js";

const FLOORS = VAGAS_CONFIG.FLOORS;
const SIDES_BY_FLOOR = VAGAS_CONFIG.SIDES_BY_FLOOR;
const POSITIONS = VAGAS_CONFIG.POSITIONS;

// Debug das configura√ß√µes
console.log('üîß VAGAS_CONFIG.VAGAS_POR_LADO:', VAGAS_CONFIG.VAGAS_POR_LADO);

// Natural pairs: generate pairs (1-2, 3-4, 5-6, ...) based on vagas por lado
const NATURAL_PAIRS = [];
for (let i = 1; i <= VAGAS_CONFIG.VAGAS_POR_LADO; i += 2) {
  const par = [i, i + 1];
  NATURAL_PAIRS.push(par);
}
console.log('üîß NATURAL_PAIRS criados:', NATURAL_PAIRS);

/* ===== Paleta: estados das vagas ===== */
const COLORS = {
  free: "#16a34a",      // verde (livre)
  extended: "#f97316",  // laranja (vaga estendida)
  selected: "#60a5fa",  // azul claro (escolhida/ocupada)
  // reserved: "#facc15",  // (n√£o mostrar mais)
  blocked: "#475569",   // cinza (bloqueada)
  base: "#1f2937"       // default
};



/* ===== Modelo garagem ===== */
function buildInitialGarage() {
  console.log('üèóÔ∏è buildInitialGarage: iniciando cria√ß√£o da garagem...');
  console.log('üèóÔ∏è FLOORS:', FLOORS);
  console.log('üèóÔ∏è SIDES_BY_FLOOR:', SIDES_BY_FLOOR);
  console.log('üèóÔ∏è NATURAL_PAIRS:', NATURAL_PAIRS);

  const spots = []; // {id,floor,side,pos,parId,blocked,occupiedBy}
  const pairs = {}; // parId -> {id,floor,side,aPos,bPos,aId,bId,reservedFor}

  for (const floor of FLOORS) {
    for (const side of SIDES_BY_FLOOR[floor]) {
      for (const [p1, p2] of NATURAL_PAIRS) {
        const parId = `${floor}-${side}-${p1}-${p2}`;
        const aId = `${floor}-${side}${p1}`;
        const bId = `${floor}-${side}${p2}`;

        console.log(`üèóÔ∏è Criando par: ${parId} -> A:${aId}, B:${bId}`);

        pairs[parId] = {
          id: parId,
          floor,
          side,
          aPos: p1,
          bPos: p2,
          aId,
          bId,
          reservedFor: null,
        };
      }
      for (const pos of POSITIONS) {
        const naturalPair = NATURAL_PAIRS.find(([a, b]) => a === pos || b === pos);
        const [p1, p2] = naturalPair || [pos, pos]; // fallback para posi√ß√µes sem par
        spots.push({
          id: `${floor}-${side}${pos}`,
          floor,
          side,
          pos,
          parId: `${floor}-${side}-${p1}-${p2}`,
          blocked: false,
          occupiedBy: null,
        });
      }
    }
  }

  console.log('üèóÔ∏è buildInitialGarage: criados', Object.keys(pairs).length, 'pares');
  console.log('üèóÔ∏è buildInitialGarage: criados', spots.length, 'spots');
  console.log('üèóÔ∏è buildInitialGarage: pares criados:', Object.keys(pairs));

  return { spots, pairs };
}

/* ===== Lista de apartamentos: 4 por andar, 7 andares (1..7) ===== */
function buildInitialApartments() {
  const list = [];
  for (let andar = 1; andar <= 7; andar++) {
    for (let col = 1; col <= 4; col++) {
      const num = Number.parseInt(`${andar}0${col}`); // 101..104, 201..204, ..., 701..704
      const temDireitoDupla = apartamentoTemDireitoDupla(num);
      const podeVagaEstendida = apartmentoPodeVagaEstendida(num);
      const tipo = getExclusiveApartmentType(num);
      list.push({
        id: num,
        dupla: temDireitoDupla,
        estendida: podeVagaEstendida,
        tipo: tipo,
        sorteado: false,
        vagas: [],
        ativo: true
      });
    }
  }
  return list;
}

/* ===== Componente principal ===== */
export default function GarageLotteryApp() {
  /* Estado */
  const [seed, setSeed] = useState(12345);
  const [configLoaded, setConfigLoaded] = useState(false);
  const rng = useRef(mulberry32(12345));
  const [compact, setCompact] = useState(true); // densidade de layout
  const [garage, setGarage] = useState(buildInitialGarage());
  const [apartments, setApartments] = useState(buildInitialApartments());  // Carrega apartamentos imediatamente

  /* Carregamento da configura√ß√£o */
  useEffect(() => {
    const loadConfig = async () => {
      console.log('üîÑ Tentando carregar configura√ß√£o do arquivo...');
      const loaded = await loadConfigFromFile();
      if (loaded) {
        console.log('‚úÖ Configura√ß√£o carregada com sucesso!');
      } else {
        console.log('‚ö†Ô∏è Usando configura√ß√£o padr√£o (hardcoded)');
      }

      // Sempre inicializa os apartamentos ap√≥s tentar carregar a config
      console.log('üè¢ Inicializando apartamentos...');
      setApartments(buildInitialApartments());
      setConfigLoaded(true);
    };

    loadConfig();
  }, []);

  /* Valida√ß√£o da configura√ß√£o */
  const configValidation = validateConfigExclusivity();
  if (!configValidation.isValid) {
    console.warn('‚ö†Ô∏è Problemas na configura√ß√£o detectados:', configValidation.errors);
  }
  const [doubleReservations, setDoubleReservations] = useState(null); // aptId -> parId  
  const [extendedReservations, setExtendedReservations] = useState(null); // aptId -> spotId
  const [preprocessed, setPreprocessed] = useState(false);
  const [lastDraw, setLastDraw] = useState(null); // { aptId, vagas }


  /* Helpers */
  const log = (...a) => console.log("[Sorteio]", ...a);
  const resetRng = (s) => (rng.current = mulberry32(Number(s) || 0));
  const pick = (arr) => {
    const result = !arr.length ? null : arr[Math.floor(rng.current() * arr.length)];
    if (!result && arr.length === 0) {
      console.log(`‚ö†Ô∏è [pick] Array vazio recebido!`);
    }
    return result;
  };

  const getFreePairs = (state) => {
    console.log('üîç ========== AN√ÅLISE DETALHADA DE getFreePairs ==========');
    console.log('üîç Vagas estendidas esperadas: [7, 8, 21, 22, 35, 36]');

    // Debug das configura√ß√µes
    console.log('üîç VAGAS_CONFIG.VAGAS_POR_LADO:', VAGAS_CONFIG.VAGAS_POR_LADO);
    console.log('üîç NATURAL_PAIRS:', NATURAL_PAIRS);
    console.log('üîç FLOORS:', FLOORS);
    console.log('üîç SIDES_BY_FLOOR:', SIDES_BY_FLOOR);
    console.log('üîç Total de pares dispon√≠veis:', Object.keys(state.pairs).length);

    const free = [];
    let totalPares = 0;
    let paresExcluidos = 0;
    let paresOcupados = 0;

    for (const id in state.pairs) {
      totalPares++;
      const p = state.pairs[id];
      const a = state.spots.find((s) => s.id === p.aId);
      const b = state.spots.find((s) => s.id === p.bId);

      if (!a || !b) {
        console.log(`‚ùå Par ${p.id}: vaga A ou B n√£o encontrada (A:${!!a}, B:${!!b})`);
        continue;
      }

      // Converte IDs das vagas para n√∫meros sequenciais
      const vagaNumA = positionToSequentialNumber(a.floor, a.side, a.pos);
      const vagaNumB = positionToSequentialNumber(b.floor, b.side, b.pos);

      console.log(`üîç Par ${totalPares}: ${p.id} ‚Üí A:${a.floor}-${a.side}${a.pos}(seq=${vagaNumA}) + B:${b.floor}-${b.side}${b.pos}(seq=${vagaNumB})`);

      // Verifica se s√£o estendidas
      const aEstendida = isVagaEstendida(vagaNumA);
      const bEstendida = isVagaEstendida(vagaNumB);

      console.log(`üîç   ‚Üí Estendidas? A(${vagaNumA})=${aEstendida}, B(${vagaNumB})=${bEstendida}`);

      if (aEstendida || bEstendida) {
        paresExcluidos++;
        console.log(`üö´   ‚Üí Par ${p.id} EXCLU√çDO por ter vaga estendida`);
        continue;
      }

      // Verifica se est√£o livres
      const aLivre = !a.occupiedBy && !a.blocked;
      const bLivre = !b.occupiedBy && !b.blocked;

      console.log(`üîç   ‚Üí Livres? A=${aLivre}(ocu:${a.occupiedBy},bloc:${a.blocked}), B=${bLivre}(ocu:${b.occupiedBy},bloc:${b.blocked})`);

      if (aLivre && bLivre) {
        console.log(`‚úÖ   ‚Üí Par ${p.id} ADICIONADO como LIVRE!`);
        free.push(p);
      } else {
        paresOcupados++;
        console.log(`‚ùå   ‚Üí Par ${p.id} ocupado/bloqueado`);
      }
    }

    console.log('üîç ========== RESUMO FINAL ==========');
    console.log('üîç Total de pares:', totalPares);
    console.log('üîç Pares exclu√≠dos (cont√©m vaga estendida):', paresExcluidos);
    console.log('üîç Pares ocupados/bloqueados:', paresOcupados);
    console.log('üîç Pares livres:', free.length);
    console.log('üîç Pares livres IDs:', free.map(p => p.id));
    console.log('üîç ==========================================');

    return free;
  };

  const getFreeExtendedSpots = (state) => {
    const free = [];
    for (const spot of state.spots) {
      if (!spot.occupiedBy && !spot.blocked) {
        const vagaNum = positionToSequentialNumber(spot.floor, spot.side, spot.pos);
        if (isVagaEstendida(vagaNum)) {
          free.push(spot);
        }
      }
    }
    return free;
  };
  const countByRegion = (state) => {
    const m = new Map();
    for (const f of FLOORS) for (const s of SIDES_BY_FLOOR[f]) m.set(`${f}-${s}`, 0);
    for (const sp of state.spots)
      if (sp.occupiedBy)
        m.set(
          `${sp.floor}-${sp.side}`,
          (m.get(`${sp.floor}-${sp.side}`) || 0) + 1
        );
    return m;
  };
  const chooseBalancedPair = (pairsList, state) => {
    if (pairsList.length <= 1) return pick(pairsList);
    const rc = countByRegion(state);
    const min = Math.min(
      ...pairsList.map((p) => rc.get(`${p.floor}-${p.side}`) || 0)
    );
    return pick(pairsList.filter((p) => (rc.get(`${p.floor}-${p.side}`) || 0) === min));
  };
  const chooseBalancedSpot = (spotsList, state) => {
    console.log(`üéØ [chooseBalancedSpot] Lista recebida:`, spotsList?.length || 0, 'spots');
    console.log(`üéØ [chooseBalancedSpot] Spots IDs:`, spotsList?.map(s => s.id) || []);

    if (!spotsList || spotsList.length === 0) {
      console.log(`‚ùå [chooseBalancedSpot] Lista vazia ou null!`);
      return null;
    }

    if (spotsList.length <= 1) {
      const chosen = pick(spotsList);
      console.log(`‚úÖ [chooseBalancedSpot] Escolhido (lista pequena):`, chosen?.id || 'null');
      return chosen;
    }

    const rc = countByRegion(state);
    const min = Math.min(
      ...spotsList.map((s) => rc.get(`${s.floor}-${s.side}`) || 0)
    );
    const balanced = spotsList.filter((s) => (rc.get(`${s.floor}-${s.side}`) || 0) === min);
    const chosen = pick(balanced);
    console.log(`‚úÖ [chooseBalancedSpot] Escolhido (balanceado):`, chosen?.id || 'null');
    return chosen;
  };

  /* Pr√©-processo oculto: 
     1. Reserva pares para apartamentos duplos
     2. Reserva vagas estendidas para apartamentos com direito
     As reservas s√£o balanceadas por regi√£o e N√ÉO aparecem visualmente (apenas em log).
  */
  const runPreprocessIfNeeded = () => {
    console.log('üèÅ runPreprocessIfNeeded: INICIANDO');
    console.log('üèÅ preprocessed:', preprocessed, 'doubleReservations:', !!doubleReservations, 'extendedReservations:', !!extendedReservations);

    if (preprocessed && doubleReservations && extendedReservations) {
      console.log('üèÅ Pr√©-processo j√° realizado, pulando...');
      return;
    }

    console.log('üèÅ Executando pr√©-processo...');
    const state = structuredClone({ spots: garage.spots, pairs: garage.pairs });

    // === RESERVA DE PARES PARA DUPLAS ===
    console.log('üèÅ FASE 1: Reservando pares para apartamentos duplos');

    const duplos = apartments.filter((a) => a.dupla && a.ativo).map((a) => a.id);
    console.log('üèÅ Apartamentos duplos encontrados:', duplos.length, '‚Üí', duplos);

    const freePairs = getFreePairs(state);
    console.log('üèÅ Pares livres encontrados:', freePairs.length, '‚Üí', freePairs.map(p => p.id));

    if (duplos.length > freePairs.length) {
      console.error('üö® PROBLEMA ENCONTRADO!');
      console.error('üö® Apartamentos duplos:', duplos.length);
      console.error('üö® Pares livres:', freePairs.length);
      console.error('üö® Diferen√ßa:', duplos.length - freePairs.length, 'pares em falta');
      alert(
        `N√£o h√° pares suficientes: duplas=${duplos.length}, pares livres=${freePairs.length}`
      );
      return;
    }

    const orderDuplas = seededShuffle(duplos, rng.current);
    const reservationsPairs = {};
    for (const aptId of orderDuplas) {
      const free = getFreePairs(state);
      if (!free.length) break;
      const chosen = chooseBalancedPair(free, state);
      reservationsPairs[aptId] = chosen.id;
      // Marca internamente no snapshot s√≥ para impedir reuso no balanceamento deste loop
      state.spots.find((s) => s.id === chosen.aId).occupiedBy = `RESERVA-DUPLA-${aptId}`;
      state.spots.find((s) => s.id === chosen.bId).occupiedBy = `RESERVA-DUPLA-${aptId}`;
      log("Pr√©-processo: reservado par", chosen.id, "para apartamento duplo", aptId);
    }

    // === RESERVA DE VAGAS EXTENDIDAS ===
    const extendidos = apartments.filter((a) => a.estendida && a.ativo && !a.dupla).map((a) => a.id);
    const freeExtended = getFreeExtendedSpots(state);

    if (extendidos.length > freeExtended.length) {
      alert(
        `N√£o h√° vagas estendidas suficientes: apartamentos=${extendidos.length}, vagas estendidas livres=${freeExtended.length}`
      );
      return;
    }

    const orderEstendidas = seededShuffle(extendidos, rng.current);
    const reservationsExtended = {};
    for (const aptId of orderEstendidas) {
      const free = getFreeExtendedSpots(state);
      if (!free.length) break;
      const chosen = chooseBalancedSpot(free, state);
      reservationsExtended[aptId] = chosen.id;
      // Marca internamente no snapshot
      state.spots.find((s) => s.id === chosen.id).occupiedBy = `RESERVA-EXTENDIDA-${aptId}`;
      const vagaNum = positionToSequentialNumber(chosen.floor, chosen.side, chosen.pos);
      log("Pr√©-processo: reservada vaga estendida", vagaNum, "para apartamento", aptId);
    }

    // === RESTAURA SNAPSHOT E APLICA RESERVAS ===
    const restored = state.spots.map((s) => ({ ...s, occupiedBy: null }));
    const newPairs = { ...garage.pairs };

    // Aplica reservas de pares
    for (const aptId in reservationsPairs) {
      newPairs[reservationsPairs[aptId]] = {
        ...newPairs[reservationsPairs[aptId]],
        reservedFor: aptId, // apenas flag interna
      };
    }

    // Aplica reservas de vagas estendidas (marca os spots)
    const newSpots = restored.map(spot => {
      for (const aptId in reservationsExtended) {
        if (reservationsExtended[aptId] === spot.id) {
          return { ...spot, reservedFor: aptId };
        }
      }
      return spot;
    });

    setGarage({ spots: newSpots, pairs: newPairs });
    setDoubleReservations(reservationsPairs);
    setExtendedReservations(reservationsExtended);
    setPreprocessed(true);
  };

  /* Sorteio (1 por clique) */
  const drawOne = () => {
    runPreprocessIfNeeded();

    const pend = apartments.filter((a) => a.ativo && !a.sorteado);
    if (!pend.length) return alert("Todos os apartamentos participantes foram sorteados.");

    const apt = pick(pend);
    console.log(`üé≤ [drawOne] Apartamento sorteado: ${apt.id} (tipo: ${apt.dupla ? 'DUPLA' : (apt.extendida ? 'EXTENDIDA' : 'SIMPLES')})`);

    if (apt.dupla) {
      const parId = doubleReservations?.[apt.id];
      setGarage((prev) => {
        // escolhe sempre com base no estado atual
        console.log(`üéØ [drawOne] Apt ${apt.id} precisa de vaga dupla. Chamando getFreePairs...`);
        let pair = parId ? prev.pairs[parId] : pick(getFreePairs(prev));
        console.log(`üéØ [drawOne] Par selecionado para apt ${apt.id}:`, pair);
        if (!pair) {
          alert(`Sem par livre para ${apt.id}`);
          return prev;
        }

        // revalida se as vagas est√£o realmente livres
        const spotA = prev.spots.find((s) => s.id === pair.aId);
        const spotB = prev.spots.find((s) => s.id === pair.bId);
        if (spotA.occupiedBy || spotB.occupiedBy) {
          // j√° ocupadas -> tenta outro par livre
          const livres = getFreePairs(prev);
          if (!livres.length) {
            alert(`Sem par livre para ${apt.id}`);
            return prev;
          }
          pair = pick(livres);
        }

        const updatedSpots = prev.spots.map((s) =>
          s.id === pair.aId || s.id === pair.bId ? { ...s, occupiedBy: apt.id } : s
        );
        const updatedPairs = { ...prev.pairs };
        if (updatedPairs[pair.id]?.reservedFor === apt.id) updatedPairs[pair.id].reservedFor = null;

        // atualiza tamb√©m os apartamentos
        setApartments((prevApts) =>
          prevApts.map((a) =>
            a.id === apt.id ? { ...a, sorteado: true, vagas: [pair.aId, pair.bId] } : a
          )
        );
        setLastDraw({ aptId: apt.id, vagas: [pair.aId, pair.bId] });



        return { spots: updatedSpots, pairs: updatedPairs };
      });
    } else {
      // Apartamento simples ou extendido
      console.log(`üîç [drawOne] Apt ${apt.id} √© ${apt.dupla ? 'DUPLA' : (apt.extendida ? 'EXTENDIDA' : 'SIMPLES')}`);
      setGarage((prev) => {
        console.log(`üîç [drawOne] Total de spots:`, prev.spots.length);
        console.log(`üîç [drawOne] Spots livres:`, prev.spots.filter(s => !s.blocked && !s.occupiedBy).length);

        let chosenSpot = null;

        // Se o apartamento tem direito a vaga extendida E tem reserva
        if (apt.extendida && extendedReservations?.[apt.id]) {
          const reservedSpotId = extendedReservations[apt.id];
          const reservedSpot = prev.spots.find(s => s.id === reservedSpotId);

          // Verifica se a vaga reservada ainda est√° livre
          if (reservedSpot && !reservedSpot.occupiedBy) {
            chosenSpot = reservedSpot;
            const vagaNum = positionToSequentialNumber(chosenSpot.floor, chosenSpot.side, chosenSpot.pos);
            console.log(`üéØ Apartamento extendido ${apt.id} recebeu vaga estendida reservada ${vagaNum}`);
          }
        }


        // Se n√£o conseguiu usar a reserva, busca vaga dispon√≠vel
        if (!chosenSpot) {
          // Lista de vagas livres (sem reservas de pares e n√£o ocupadas)
          const allFree = prev.spots.filter(
            (s) =>
              !s.blocked &&
              !s.occupiedBy &&
              !prev.pairs[s.parId]?.reservedFor &&
              !s.reservedFor // n√£o est√° reservada para outro apartamento extendido
          );

          console.log(`üîç [drawOne] Apt ${apt.id} - Vagas totalmente livres:`, allFree.length);
          console.log(`üîç [drawOne] Apt ${apt.id} - IDs das vagas livres:`, allFree.map(s => s.id));
          console.log(`üîç [drawOne] Apt ${apt.id} - Detalhes vagas livres:`, allFree.map(s => ({
            id: s.id,
            floor: s.floor,
            side: s.side,
            pos: s.pos,
            parId: s.parId,
            blocked: s.blocked,
            occupiedBy: s.occupiedBy,
            reservedFor: s.reservedFor,
            pairReserved: prev.pairs[s.parId]?.reservedFor
          })));

          if (!allFree.length) {
            console.log(`‚ùå [drawOne] Apt ${apt.id} - SEM VAGAS LIVRES! Mostrando an√°lise detalhada:`);
            console.log(`üîç Total spots:`, prev.spots.length);
            console.log(`üîç Spots bloqueados:`, prev.spots.filter(s => s.blocked).length);
            console.log(`üîç Spots ocupados:`, prev.spots.filter(s => s.occupiedBy).length);
            console.log(`üîç Spots com par reservado:`, prev.spots.filter(s => prev.pairs[s.parId]?.reservedFor).length);
            console.log(`üîç Spots reservados para apt extendido:`, prev.spots.filter(s => s.reservedFor).length);
            alert("Sem vaga dispon√≠vel.");
            return prev;
          }

          // Separa vagas estendidas e vagas normais dispon√≠veis
          const extendedFree = allFree.filter(s => {
            const vagaNum = positionToSequentialNumber(s.floor, s.side, s.pos);
            return isVagaEstendida(vagaNum);
          });

          const normalFree = allFree.filter(s => {
            const vagaNum = positionToSequentialNumber(s.floor, s.side, s.pos);
            return !isVagaEstendida(vagaNum);
          });

          console.log(`üîç [drawOne] Apt ${apt.id} - Vagas extendidas livres:`, extendedFree.length);
          console.log(`üîç [drawOne] Apt ${apt.id} - IDs vagas extendidas:`, extendedFree.map(s => s.id));
          console.log(`üîç [drawOne] Apt ${apt.id} - Vagas normais livres:`, normalFree.length);
          console.log(`üîç [drawOne] Apt ${apt.id} - IDs vagas normais:`, normalFree.map(s => s.id));

          if (apt.extendida) {
            // Apartamento com direito a vaga estendida: prioriza vagas estendidas
            if (extendedFree.length > 0) {
              chosenSpot = chooseBalancedSpot(extendedFree, prev);
              const vagaNum = positionToSequentialNumber(chosenSpot.floor, chosenSpot.side, chosenSpot.pos);
              console.log(`üü† Apartamento extendido ${apt.id} recebeu vaga estendida ${vagaNum}`);
            } else if (normalFree.length > 0) {
              // fallback: se n√£o sobrou nenhuma estendida livre, pode usar vaga normal
              chosenSpot = chooseBalancedSpot(normalFree, prev);
              const vagaNum = positionToSequentialNumber(chosenSpot.floor, chosenSpot.side, chosenSpot.pos);
              console.log(`‚úÖ Apartamento extendido ${apt.id} recebeu vaga normal ${vagaNum} (sem vagas estendidas dispon√≠veis)`);
            }
          } else {
            // Apartamento simples:
            console.log(`üîç [drawOne] Apt ${apt.id} √© SIMPLES - analisando vagas dispon√≠veis...`);
            // 1) Enquanto houver vaga normal, s√≥ pode receber vaga normal
            // 2) Se acabarem as vagas normais, pode usar vaga estendida que sobrou
            if (normalFree.length > 0) {
              chosenSpot = chooseBalancedSpot(normalFree, prev);
              const vagaNum = positionToSequentialNumber(chosenSpot.floor, chosenSpot.side, chosenSpot.pos);
              console.log(`‚úÖ Apartamento simples ${apt.id} recebeu vaga normal ${vagaNum}`);
            } else if (extendedFree.length > 0) {
              chosenSpot = chooseBalancedSpot(extendedFree, prev);
              const vagaNum = positionToSequentialNumber(chosenSpot.floor, chosenSpot.side, chosenSpot.pos);
              console.log(`üü° Apartamento simples ${apt.id} recebeu vaga estendida ${vagaNum} (todas as vagas normais ocupadas)`);
            } else {
              console.log(`‚ùå [drawOne] Apt ${apt.id} SIMPLES - SEM VAGAS! normalFree=${normalFree.length}, extendedFree=${extendedFree.length}`);
              alert(`Apartamento simples ${apt.id} n√£o pode receber vaga - todas as vagas est√£o ocupadas.`);
              return prev;
            }
          }
        }

        if (!chosenSpot) {
          console.log(`‚ùå [drawOne] Apt ${apt.id} - FALHA! chosenSpot √© null/undefined`);
          console.log(`‚ùå [drawOne] Apt ${apt.id} - Estado: dupla=${apt.dupla}, extendida=${apt.extendida}`);
          console.log(`‚ùå [drawOne] Apt ${apt.id} - normalFree.length=${normalFree?.length || 'undefined'}, extendedFree.length=${extendedFree?.length || 'undefined'}`);

          // üö® CORRE√á√ÉO: N√ÉO marcar apartamento como sorteado se n√£o conseguiu vaga
          console.log(`üö® [drawOne] Apt ${apt.id} - N√ÉO SER√Å MARCADO COMO SORTEADO (sem vaga dispon√≠vel)`);
          alert(`Sem vaga dispon√≠vel para apartamento ${apt.id}.`);
          return prev;
        }

        console.log(`‚úÖ [drawOne] Apt ${apt.id} - Vaga escolhida:`, chosenSpot.id);

        // üîí PROTE√á√ÉO: S√≥ marca como sorteado AP√ìS confirmar que tem vaga v√°lida
        if (!chosenSpot.id) {
          console.log(`‚ùå [drawOne] Apt ${apt.id} - Vaga escolhida n√£o tem ID v√°lido!`);
          alert(`Erro interno: vaga inv√°lida para apartamento ${apt.id}.`);
          return prev;
        }

        // Remove a reserva se foi usada
        const updatedSpots = prev.spots.map((s) =>
          s.id === chosenSpot.id ? { ...s, occupiedBy: apt.id, reservedFor: null } : s
        );

        // ‚úÖ CORRE√á√ÉO TOTAL: Estados s√≠ncronos para evitar condi√ß√£o de corrida
        console.log(`‚úÖ [drawOne] Apt ${apt.id} - AGORA marcando como sorteado e atribuindo vaga ${chosenSpot.id}`);
        console.log(`üîí [drawOne] Apt ${apt.id} - Prote√ß√£o: vaga confirmada antes de marcar sorteado`);

        // üîÑ ESTADO S√çNCRONO: Atualizar apartments primeiro, garage depois
        setApartments((prevApts) => {
          const updatedApts = prevApts.map((a) =>
            a.id === apt.id ? { ...a, sorteado: true, vagas: [chosenSpot.id] } : a
          );

          console.log(`üîÑ [drawOne] Apt ${apt.id} - Estado apartments atualizado ANTES de garage`);

          // üîÑ Depois atualizar garage (garantindo sincroniza√ß√£o)
          setTimeout(() => {
            setLastDraw({ aptId: apt.id, vagas: [chosenSpot.id] });
          }, 0);

          return updatedApts;
        });

        return { ...prev, spots: updatedSpots };
      });
    }
  };


  /* üîß CORRE√á√ÉO DE √ìRF√ÉOS - SOLU√á√ÉO AT√îMICA */
  const fixOrphanedApartments = () => {
    console.log('üîß [CORRE√á√ÉO AT√îMICA] Iniciando...');

    // ‚ö° CAPTURA DE ESTADO ATUAL (sem callbacks)
    const orphanedApts = apartments.filter(a => a.sorteado && a.vagas.length === 0);
    const freeSpots = garage.spots.filter(s => !s.blocked && !s.occupiedBy && !s.reservedFor);
    
    console.log(`üîß √ìrf√£os encontrados: ${orphanedApts.length}`, orphanedApts.map(a => a.id));
    console.log(`üîß Vagas livres: ${freeSpots.length}`, freeSpots.map(s => s.id));

    if (orphanedApts.length === 0) {
      alert('‚úÖ Nenhum apartamento √≥rf√£o encontrado!');
      return;
    }

    // üìã CALCULAR TODAS AS CORRE√á√ïES
    const fixes = [];
    for (let i = 0; i < Math.min(orphanedApts.length, freeSpots.length); i++) {
      fixes.push({
        aptId: orphanedApts[i].id,
        vagaId: freeSpots[i].id
      });
    }

    console.log('ÔøΩ Corre√ß√µes planejadas:', fixes);

    // ‚ö° APLICA√á√ÉO AT√îMICA - APARTMENTS
    const newApts = apartments.map(apt => {
      const fix = fixes.find(f => f.aptId === apt.id);
      if (fix) {
        console.log(`‚úÖ ${apt.id} ‚Üí Vaga ${fix.vagaId}`);
        return { ...apt, vagas: [fix.vagaId] };
      }
      return apt;
    });

    // ‚ö° APLICA√á√ÉO AT√îMICA - GARAGE  
    const newSpots = garage.spots.map(spot => {
      const fix = fixes.find(f => f.vagaId === spot.id);
      if (fix) {
        return { ...spot, occupiedBy: fix.aptId };
      }
      return spot;
    });

    // üöÄ ATUALIZA√á√ÉO FINAL
    setApartments(newApts);
    setGarage(prev => ({ ...prev, spots: newSpots }));

    alert(`‚úÖ ${fixes.length} apartamentos √≥rf√£os corrigidos!`);
    console.log(`üéØ Corre√ß√£o conclu√≠da: ${fixes.length} corre√ß√µes aplicadas`);
  };
        console.log('‚úÖ [fixOrphanedApartments] Nenhum √≥rf√£o encontrado!');
        return prevApts;
      }

      // ÔøΩ SINCRONIZA√á√ÉO: Atualiza garage e apartments em sequ√™ncia controlada
      setGarage((prevGarage) => {
        const freeSpots = prevGarage.spots.filter(s => !s.blocked && !s.occupiedBy && !s.reservedFor);

        console.log(`üîß [fixOrphanedApartments] Vagas livres encontradas: ${freeSpots.length}`);
        console.log(`üîß [fixOrphanedApartments] IDs vagas livres:`, freeSpots.map(s => s.id));

        let updatedSpots = [...prevGarage.spots];
        let fixedCount = 0;

        // üîÑ Corrige cada √≥rf√£o
        orphanedApts.forEach((orphan, index) => {
          if (index < freeSpots.length) {
            const chosenSpot = freeSpots[index];

            // Atualiza a vaga
            const spotIndex = updatedSpots.findIndex(s => s.id === chosenSpot.id);
            if (spotIndex >= 0) {
              updatedSpots[spotIndex] = { ...chosenSpot, occupiedBy: orphan.id };
              fixedCount++;
              console.log(`‚úÖ [fixOrphanedApartments] ${orphan.id} ‚Üí Vaga ${chosenSpot.id}`);
            }
          }
        });

        console.log(`üéØ [fixOrphanedApartments] ${fixedCount} vagas alocadas`);
        return { ...prevGarage, spots: updatedSpots };
      });

      // üîÑ Atualiza apartamentos com as vagas
      let updatedApts = [...prevApts];

      setGarage((currentGarage) => {
        orphanedApts.forEach((orphan, index) => {
          const freeSpots = currentGarage.spots.filter(s => !s.blocked && !s.occupiedBy && !s.reservedFor);

          if (index < freeSpots.length) {
            const chosenSpot = freeSpots[index];
            const aptIndex = updatedApts.findIndex(a => a.id === orphan.id);

            if (aptIndex >= 0) {
              updatedApts[aptIndex] = { ...orphan, vagas: [chosenSpot.id] };
              console.log(`‚úÖ [fixOrphanedApartments] Apt ${orphan.id} recebeu vaga ${chosenSpot.id}`);
            }
          }
        });

        return currentGarage;
      });

      console.log(`üéØ [CORRE√á√ÉO AT√îMICA] Corre√ß√£o conclu√≠da!`);
      return updatedApts;
    });
  };

  /* Reset */
  const clearAll = () => {
    setGarage(buildInitialGarage());
    setDoubleReservations(null);
    setExtendedReservations(null);
    setPreprocessed(false);
    setApartments(buildInitialApartments());
    setLastDraw(null);
  };

  /* Fun√ß√£o para revalidar e sincronizar estados */
  const revalidateStates = () => {
    console.log('üîÑ Revalidando estados...');

    // Reconstroi completamente os estados
    const newGarage = buildInitialGarage();
    const newApartments = buildInitialApartments();

    // Aplica novamente todos os sorteios v√°lidos baseado nos apartamentos atuais
    const sortedApartments = apartments.filter(a => a.sorteado && a.vagas.length > 0);

    console.log('üìã Apartamentos sorteados encontrados:', sortedApartments.map(a => ({
      apt: a.id,
      vagas: a.vagas,
      tipo: getApartmentType(a.id)
    })));

    // Aplica cada sorteio novamente
    sortedApartments.forEach(apartment => {
      apartment.vagas.forEach(vagaId => {
        const spotIndex = newGarage.spots.findIndex(s => s.id === vagaId);
        if (spotIndex >= 0) {
          newGarage.spots[spotIndex].occupiedBy = apartment.id;
        }
      });

      const aptIndex = newApartments.findIndex(a => a.id === apartment.id);
      if (aptIndex >= 0) {
        newApartments[aptIndex] = { ...apartment };
      }
    });

    // Atualiza os estados
    setGarage(newGarage);
    setApartments(newApartments);

    console.log('‚úÖ Estados revalidados e sincronizados');
  };

  /* Fun√ß√£o para debug da vaga 22 */
  const debugVaga22 = () => {
    console.log('üîç DEBUG - Investigando vaga 22...');

    // Encontrar a vaga 22 no estado
    const vaga22 = garage.spots.find(s => {
      const vagaNumber = positionToSequentialNumber(s.floor, s.side, s.pos);
      return vagaNumber === 22;
    });

    console.log('üìç Vaga 22 encontrada:', vaga22);

    // Encontrar qual apartamento deveria ter a vaga 22
    const apartamentoComVaga22 = apartments.find(a =>
      a.vagas.some(vagaId => {
        const [floor, sidePos] = vagaId.split('-');
        const side = sidePos.charAt(0);
        const pos = Number.parseInt(sidePos.slice(1));
        const vagaNumber = positionToSequentialNumber(floor, side, pos);
        return vagaNumber === 22;
      })
    );

    console.log('üè† Apartamento que deveria ter vaga 22:', apartamentoComVaga22);

    // Verificar apartamento 502 especificamente
    const apt502 = apartments.find(a => a.id === 502);
    console.log('üè† Apartamento 502:', apt502);

    // Verificar apartamento 302 especificamente  
    const apt302 = apartments.find(a => a.id === 302);
    console.log('üè† Apartamento 302:', apt302);
  };
  const generatePrintList = () => {
    // Revalida√ß√£o autom√°tica antes de gerar o PDF para garantir consist√™ncia
    console.log('üîÑ Sincronizando estados antes da impress√£o...');

    const sortedApartments = apartments
      .filter(a => a.sorteado && a.vagas.length > 0)
      .sort((a, b) => a.id - b.id);

    // Valida√ß√£o autom√°tica: verificar consist√™ncia entre apartamentos e visualiza√ß√£o
    let inconsistencyFound = false;
    for (const apartment of sortedApartments) {
      for (const vagaId of apartment.vagas) {
        const spot = garage.spots.find(s => s.id === vagaId);
        if (spot && spot.occupiedBy !== apartment.id) {
          console.warn(`‚ö†Ô∏è Inconsist√™ncia detectada: Vaga ${vagaId} no apartamento ${apartment.id} mas visualiza√ß√£o mostra ${spot.occupiedBy}`);
          inconsistencyFound = true;
        }
      }
    }

    if (inconsistencyFound) {
      console.log('üîß Corrigindo inconsist√™ncias automaticamente...');
      // Aplicar corre√ß√£o autom√°tica
      setGarage((prevGarage) => {
        const newGarage = { ...prevGarage };
        newGarage.spots = newGarage.spots.map(spot => {
          // Resetar ocupa√ß√£o
          const newSpot = { ...spot, occupiedBy: null };

          // Reaplicar baseado nos apartamentos sorteados
          const ownerApartment = sortedApartments.find(apt =>
            apt.vagas.includes(spot.id)
          );

          if (ownerApartment) {
            newSpot.occupiedBy = ownerApartment.id;
          }

          return newSpot;
        });
        return newGarage;
      });

      console.log('‚úÖ Estados sincronizados automaticamente');
    }

    const now = new Date();
    const dateStr = now.toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('pt-BR', {
      hour: '2-digit',
      minute: '2-digit'
    });

    let printContent = `
<!DOCTYPE html>
<html>
<head>
    <title>Resultado do Sorteio de Garagens - Flor de Lis</title>
    <style>
        @page { margin: 2cm; }
        body { 
            font-family: Arial, sans-serif; 
            line-height: 1.4; 
            color: #333;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
            padding-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
            font-weight: bold;
        }
        .header .subtitle {
            font-size: 18px;
            margin: 10px 0;
            color: #666;
        }
        .date-info {
            font-size: 14px;
            color: #888;
        }
        .summary {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .summary h2 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .results-table th,
        .results-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .results-table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .results-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .apartment-type {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        .type-dupla { background: #fef3c7; color: #92400e; }
        .type-simples { background: #dbeafe; color: #1e40af; }
        .type-estendida { background: #f3e8ff; color: #6b21a8; }
        .footer {
            margin-top: 40px;
            text-align: center;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RESULTADO DO SORTEIO DE GARAGENS</h1>
        <div class="subtitle">Edif√≠cio Flor de Lis</div>
        <div class="date-info">
            Sorteio realizado em: ${dateStr} √†s ${timeStr}
        </div>
    </div>

    <div class="summary">
        <h2>üìä Resumo do Sorteio</h2>
        <p><strong>Total de apartamentos sorteados:</strong> ${sortedApartments.length}</p>
        <p><strong>Total de vagas atribu√≠das:</strong> ${sortedApartments.reduce((sum, apt) => sum + apt.vagas.length, 0)}</p>
        <p><strong>Apartamentos duplos:</strong> ${sortedApartments.filter(a => getApartmentType(a.id) === 'dupla').length}</p>
        <p><strong>Apartamentos simples:</strong> ${sortedApartments.filter(a => getApartmentType(a.id) === 'simples').length}</p>
        <p><strong>Apartamentos extendidos:</strong> ${sortedApartments.filter(a => getApartmentType(a.id) === 'estendida').length}</p>
    </div>

    <table class="results-table">
        <thead>
            <tr>
                <th>Apartamento</th>
                <th>Tipo</th>
                <th>Vaga(s) Sorteada(s)</th>
                <th>Andar da Garagem</th>
            </tr>
        </thead>
        <tbody>`;

    sortedApartments.forEach(apartment => {
      const type = getApartmentType(apartment.id);
      const typeClass = `type-${type}`;

      // Converter IDs das vagas para n√∫meros sequenciais
      const vagasSequenciais = apartment.vagas.map(vagaId => {
        // vagaId est√° no formato "G1-A1", "G2-C5", etc.
        const [floor, sidePos] = vagaId.split('-');
        const side = sidePos.charAt(0); // A, B, C, D, E, F
        const pos = parseInt(sidePos.slice(1)); // 1, 2, 3, etc.
        return positionToSequentialNumber(floor, side, pos);
      });

      const vagasStr = vagasSequenciais.join(', ');

      // Determinar andar da garagem baseado na primeira vaga
      let andarGaragem = '';
      if (vagasSequenciais.length > 0) {
        const primeiraVaga = vagasSequenciais[0];
        if (primeiraVaga <= 14) andarGaragem = 'G1';
        else if (primeiraVaga <= 28) andarGaragem = 'G2';
        else andarGaragem = 'G3';
      }

      printContent += `
            <tr>
                <td><strong>${apartment.id}</strong></td>
                <td><span class="apartment-type ${typeClass}">${type.toUpperCase()}</span></td>
                <td>${vagasStr}</td>
                <td>${andarGaragem}</td>
            </tr>`;
    });

    printContent += `
        </tbody>
    </table>

    <div class="footer">
        <p>Sistema de Sorteio de Garagens - Flor de Lis</p>
        <p>Documento gerado automaticamente em ${dateStr} √†s ${timeStr}</p>
    </div>
</body>
</html>`;

    // Abrir em nova janela para impress√£o
    const printWindow = window.open('', '_blank');
    printWindow.document.write(printContent);
    printWindow.document.close();

    // Aguardar carregamento e abrir di√°logo de impress√£o
    setTimeout(() => {
      printWindow.focus();
      printWindow.print();
    }, 500);
  };

  /* Handlers */
  // Fun√ß√£o para determinar o tipo do apartamento
  const getApartmentType = (apartmentId) => {
    return getExclusiveApartmentType(apartmentId);
  };

  // Fun√ß√£o para obter a cor do badge baseado no tipo
  const getBadgeStyle = (type) => {
    const styles = {
      simples: { background: "#dbeafe", color: "#1e40af" },
      dupla: { background: "#fef3c7", color: "#92400e" },
      estendida: { background: "#f3e8ff", color: "#6b21a8" }
    };
    return styles[type] || styles.simples;
  };

  const toggleSpotBlock = (spotId) => {
    setGarage((prev) => ({
      ...prev,
      spots: prev.spots.map((s) =>
        s.id === spotId ? { ...s, blocked: !s.blocked } : s
      ),
    }));
    // Reset preprocessamento ao alterar bloqueios
    setDoubleReservations(null);
    setPreprocessed(false);
  };

  const onSeed = (v) => {
    setSeed(v);
    resetRng(v);
  };

  const pending = apartments.filter((a) => a.ativo && !a.sorteado).length;

  /* ===== Helpers de UI ===== */
  // IMPORTANTE: n√£o mostramos mais o estado de reservado visualmente.
  const spotBgColor = (spot) => {
    if (spot.blocked) return COLORS.blocked;
    if (spot.occupiedBy) return COLORS.selected;

    // Verificar se √© uma vaga estendida
    const vagaNumber = positionToSequentialNumber(spot.floor, spot.side, spot.pos);
    if (isVagaEstendida(vagaNumber)) return COLORS.extended;

    return COLORS.free; // sempre verde se livre (mesmo que pertencente a um par reservado)
  };
  const spotTextColor = (spot) => {
    const bg = spotBgColor(spot);
    if (bg === COLORS.free || bg === COLORS.extended) return "#0b1220"; // texto escuro para fundos claros
    return "#ffffff"; // texto branco para fundos escuros
  };

  return (
    <div style={{ minHeight: "100vh", background: "#0b0f14", color: "#eaeef2" }}>
      <style>{`
        /* FULL-WIDTH + RESET */
        :root, html, body, #root { width:100%; height:100%; }
        body { margin:0; background:#0b0f14; }

        /* ====== Densidade (padr√£o: compacta) ====== */
        :root{
          --apt-col-min: 150px;
          --apt-card-pad: 8px;
          --apt-title: 13px;
          --apt-badge: 10px;
          --left-col-min: 440px;
          --left-col-max: 580px;
          --gap: 12px;
        }
        .compact {
          --apt-col-min: 130px;
          --apt-card-pad: 6px;
          --apt-title: 12px;
          --apt-badge: 9.5px;
          --left-col-min: 500px;
          --left-col-max: 640px;
          --gap: 10px;
        }

        .wrap {
          width: min(1800px, 100vw - 48px);
          margin: 0 auto;
          padding: 24px;
          box-sizing: border-box;
        }
        .twoCols {
          display: grid;
          grid-template-columns: minmax(var(--left-col-min), var(--left-col-max)) 1fr;
          gap: 24px;
          align-items: start;
        }
        .leftSticky {
  position: sticky;
  top: 16px;
  align-self: start;
  max-height: calc(100vh - 32px);
  overflow-y: auto;       /* ‚úÖ s√≥ rolagem vertical */
  overflow-x: hidden;     /* ‚úÖ impede scroll lateral */
}


        @media (max-width: 1200px) {
          .twoCols { grid-template-columns: 1fr; }
          .leftSticky { position:static; max-height:none; }
        }
      `}</style>

      <div className={`wrap ${compact ? "compact" : ""}`}>
        {/* Valida√ß√£o da Configura√ß√£o */}
        {configLoaded && !configValidation.isValid && (
          <div style={{
            background: "#fef2f2",
            border: "1px solid #fecaca",
            borderRadius: 8,
            padding: 12,
            marginBottom: 16,
            color: "#b91c1c"
          }}>
            <strong>‚ö†Ô∏è Problemas na configura√ß√£o:</strong>
            <ul style={{ margin: 0, paddingLeft: 20 }}>
              {configValidation.errors.map((error, idx) => (
                <li key={`error-${idx}`}>{error}</li>
              ))}
            </ul>
          </div>
        )}

        {/* Status do carregamento da configura√ß√£o */}
        <div style={{
          background: configLoaded ? "#f0fdf4" : "#fef3c7",
          border: `1px solid ${configLoaded ? "#bbf7d0" : "#fcd34d"}`,
          borderRadius: 8,
          padding: 8,
          marginBottom: 16,
          fontSize: 14,
          color: configLoaded ? "#15803d" : "#92400e"
        }}>
          {configLoaded ? "‚úÖ Configura√ß√£o carregada" : "üîÑ Carregando configura√ß√£o..."}
        </div>

        <h1 style={{ fontSize: 32, fontWeight: 800, marginBottom: 16 }}>
          Sorteio de Garagens ‚Äî Flor de Lis
        </h1>
        <div style={{ display: "flex", gap: 12, marginBottom: 16, flexWrap: "wrap" }}>
          <input
            type="number"
            value={seed}
            onChange={(e) => onSeed(e.target.value)}
            style={{
              padding: "6px 8px",
              border: "1px solid #334155",
              borderRadius: 6,
              background: "#0b0f14",
              color: "#eaeef2",
            }}
            hidden
          />
          <button
            onClick={drawOne}
            style={{
              padding: "8px 12px",
              borderRadius: 8,
              background: "#4f46e5",
              color: "#fff",
              border: 0,
            }}
          >
            Sortear ({pending})
          </button>
          <button
            onClick={clearAll}
            style={{
              padding: "8px 12px",
              borderRadius: 8,
              background: "#1f2937",
              color: "#fff",
              border: 0,
            }}
          >
            Limpar
          </button>

          <button
            onClick={fixOrphanedApartments}
            style={{
              padding: "8px 12px",
              borderRadius: 8,
              background: "#dc2626",
              color: "#fff",
              border: 0,
            }}
            title="Corrige apartamentos marcados como sorteados mas sem vaga atribu√≠da"
          >
            üîß Corrigir √ìrf√£os
          </button>

          <button
            onClick={generatePrintList}
            style={{
              padding: "8px 12px",
              borderRadius: 8,
              background: "#059669",
              color: "#fff",
              border: 0,
            }}
          >
            üìÑ Imprimir Lista
          </button>

          <button
            onClick={() => setCompact((c) => !c)}
            style={{
              padding: "8px 12px",
              borderRadius: 8,
              background: "#0f172a",
              color: "#eaeef2",
              border: "1px solid #1e293b",
              marginLeft: "auto",
            }}
          >
            Densidade: {compact ? "Compacta" : "Conforto"}
          </button>
        </div>

        <div className="twoCols">
          {/* ESQUERDA: Apartamentos (sticky) */}
          <aside className="leftSticky">
            <div
              style={{
                background: "#0f172a",
                border: "1px solid #1e293b",
                borderRadius: 16,
                padding: 16,
              }}
            >
              {lastDraw && (
                <div
                  style={{
                    background: "#1e3a8a",
                    borderRadius: 12,
                    padding: "20px 16px",
                    marginBottom: 16,
                    textAlign: "center",
                    color: "white",
                  }}
                >
                  <div style={{ fontSize: 28, fontWeight: 800 }}>
                    √öltimo sorteado: Apto {lastDraw.aptId}
                  </div>
                  <div style={{ fontSize: 20, marginTop: 6 }}>
                    Garagem: {lastDraw.vagas.map(vagaIdToSequentialNumber).join(", ")}
                  </div>
                </div>
              )}

              <h2 style={{ fontWeight: 700, marginBottom: 8 }}>Apartamentos</h2>
              {apartments.length === 0 && (
                <div style={{ color: '#ef4444', padding: 16, background: '#fef2f2', borderRadius: 8, marginBottom: 16 }}>
                  ‚ö†Ô∏è Nenhum apartamento carregado. Verificando configura√ß√£o...
                </div>
              )}
              <div
                style={{
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(var(--apt-col-min), 1fr))",
                  gap: "var(--gap)",
                }}
              >
                {apartments.map((a) => (
                  <div
                    key={a.id}
                    style={{
                      border: a.ativo ? "1px solid #1e293b" : "1px solid #7f1d1d",
                      borderRadius: 12,
                      padding: "var(--apt-card-pad)",
                      background: a.ativo ? "#0b1220" : "#2a0b0b",
                      display: "flex",
                      flexDirection: "column",
                      gap: "calc(var(--gap) - 4px)",
                    }}
                    title={a.ativo ? "" : "N√£o participa do sorteio"}
                  >
                    <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between" }}>
                      <span
                        style={{
                          fontFamily: "ui-monospace, Menlo, Monaco",
                          fontSize: "var(--apt-title)",
                        }}
                      >
                        #{a.id}
                      </span>
                      <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                        {(() => {
                          const type = getApartmentType(a.id);
                          const style = getBadgeStyle(type);
                          const labels = {
                            simples: 'Simples',
                            dupla: 'Dupla',
                            estendida: 'Estendida'
                          };
                          return (
                            <span
                              style={{
                                fontSize: 12,
                                padding: "2px 8px",
                                borderRadius: 12,
                                fontWeight: 500,
                                ...style
                              }}
                            >
                              {labels[type]}
                            </span>
                          );
                        })()}
                      </div>
                    </div>
                    <div style={{ display: "flex", alignItems: "center", gap: "calc(var(--gap) - 4px)", flexWrap: "wrap" }}>
                      {!a.ativo && (
                        <span
                          style={{
                            fontSize: "var(--apt-badge)",
                            padding: "1px 6px",
                            borderRadius: 999,
                            background: "#fecaca",
                            color: "#7f1d1d",
                          }}
                        >
                          Inativo
                        </span>
                      )}
                      <span
                        style={{
                          fontSize: "var(--apt-badge)",
                          padding: "1px 6px",
                          borderRadius: 999,
                          background: a.dupla ? "#fef3c7" : "#d1fae5",
                          color: a.dupla ? "#92400e" : "#065f46",
                          opacity: a.ativo ? 1 : 0.7,
                        }}
                      >
                        {a.dupla ? "Dupla" : "Simples"}
                      </span>
                      {a.sorteado && (
                        <span
                          style={{
                            fontSize: "var(--apt-badge)",
                            padding: "1px 6px",
                            borderRadius: 999,
                            background: "#e0e7ff",
                            color: "#3730a3",
                          }}
                        >
                          Sorteado
                        </span>
                      )}
                      {a.vagas.length > 0 && (
                        <span style={{ fontSize: "var(--apt-badge)", color: "#94a3b8" }}>
                          {a.vagas.map(vagaIdToSequentialNumber).join(", ")}
                        </span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </aside>

          {/* DIREITA: Garagens */}
          <main>
            <div style={{ display: "grid", gap: 16 }}>
              {FLOORS.map((floor) => (
                <section
                  key={floor}
                  style={{
                    background: "#0f172a",
                    border: "1px solid #1e293b",
                    borderRadius: 16,
                    padding: 16,
                  }}
                >
                  <h2 style={{ fontWeight: 700, marginBottom: 12 }}>{floor}</h2>
                  <div
                    style={{
                      display: "grid",
                      gridTemplateColumns: "repeat(14, 1fr)",
                      gap: 8,
                      maxWidth: "100%"
                    }}
                  >
                    {SIDES_BY_FLOOR[floor].flatMap((side) =>
                      POSITIONS.map((pos) => {
                        const spot = garage.spots.find(
                          (s) => s.floor === floor && s.side === side && s.pos === pos
                        );
                        const bg = spotBgColor(spot);
                        const color = spotTextColor(spot);
                        const vagaNumber = positionToSequentialNumber(floor, side, pos);
                        return (
                          <div
                            key={spot.id}
                            title={`Vaga ${vagaNumber}${spot.occupiedBy ? ` - Apartamento ${spot.occupiedBy}` : ''}`}
                            style={{
                              height: 56,
                              width: 56,
                              borderRadius: 10,
                              display: "flex",
                              flexDirection: "column",
                              alignItems: "center",
                              justifyContent: "center",
                              border: "1px solid #0b1220",
                              background: bg,
                              color,
                              cursor: "pointer",
                              fontSize: 14,
                              fontWeight: "bold"
                            }}
                            onClick={() => toggleSpotBlock(spot.id)}
                          >
                            <span>{vagaNumber}</span>
                            {spot.occupiedBy && (
                              <span style={{ fontSize: 10 }}>apt {spot.occupiedBy}</span>
                            )}
                          </div>
                        );
                      })
                    )}
                  </div>
                </section>
              ))}
            </div>
          </main>
        </div>
      </div>
    </div>
  );
}
